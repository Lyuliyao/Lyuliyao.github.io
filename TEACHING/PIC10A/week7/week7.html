<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Section 12</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="../reveal.js/dist/reveal.css">
  <link rel="stylesheet" href="../reveal.js/dist/theme/white.css" id="theme">
  <link rel="stylesheet" href="../reveal.js/plugin/highlight/monokai.css">
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
      <h2> How to choose parameter types</h2>
      </section>
      <section>
        <h2> Different parameter types</h2>
        <ul>
          <li>
            <strong>Passing by value</strong>
            <ul>
              <li>Makes a copy of the argument</li>
              <li>Changes inside the function do <em>not</em> affect the caller</li>
              <li>Simple and safe, good for small types (e.g., <code>int</code>, <code>double</code>)</li>
            </ul>
          </li>
        </ul>
      </section>
      <section>
          <li>
            <strong>Passing by reference</strong>
            <ul>
              <li>No copy is made (more efficient for large objects)</li>
              <li>Function can modify the caller’s variable</li>
              <li>Use when you <em>want</em> to change the argument</li>
            </ul>
          </li>
        </ul>
      </section>
      <section>
          <li>
            <strong>Passing by reference to const</strong>
            <ul>
              <li>No copy is made (efficient for large objects)</li>
              <li>Function cannot modify the argument</li>
              <li>Use when you only need to read from a large object</li>
            </ul>
          </li>
        </ul>
      </section>
      <section>
      <h2>Choosing Parameter Types in C++</h2>
      <p>Given a type <code>T</code> (without <code>const</code> or <code>&</code>):</p>
      <ul>
        <li class="fragment"><strong>Pass by value</strong>: <code>T</code> (makes a copy)</li>
        <li class="fragment"><strong>Pass by reference</strong>: <code>T&amp;</code> (can modify original)</li>
        <li class="fragment"><strong>Pass by reference to const</strong>: <code>const T&amp;</code> (no copy, cannot modify)</li>
      </ul>
    </section>

    <section>
      <h2>How to Choose</h2>
      <ol>
        <li class="fragment">
          <strong>Do we want to mutate the argument?</strong>
          <ul>
            <li>If <strong>yes</strong> → use <code>T&amp;</code></li>
            <li>If <strong>no</strong> → choose between <code>T</code> and <code>const T&amp;</code></li>
          </ul>
        </li>
        <li class="fragment">
          <strong>Do we want to avoid copying?</strong>
          <ul>
            <li>If <strong>yes</strong> → use <code>T&amp;</code> or <code>const T&amp;</code></li>
            <li>If <strong>no</strong>:
              <ul>
                <li>If copying doesn’t matter → <code>T</code> is simplest</li>
                <li>If we really want a copy → use <code>T</code> (or copy inside)</li>
              </ul>
            </li>
          </ul>
        </li>
      </ol>
    </section>
    <section>
        <h2>Example 12.1.3 — Const Correctness</h2>
        <pre><code class="language-cpp" data-trim data-line-numbers>
        #include &lt;iostream&gt;
        #include &lt;vector&gt;
        using namespace std;

        int sum(const vector&lt;int&gt;& v) {
            int sum = 0;
            for (size_t i = 0, N = v.size(); i &lt; N; ++i)
                sum += v[i];
            return sum;
        }

        void print_sum(const vector&lt;int&gt;& v) {
            cout &lt;&lt; sum(v) &lt;&lt; endl;
        }

        int main() {
            vector&lt;int&gt; w{1, 2, 3};
            print_sum(w);
        }
          </code></pre>
    </section>
    <section>
      <h2>What Does “Const Correct” Mean?</h2>
      <ul>
        <li class="fragment"><code>const vector&lt;int&gt;&amp;</code> means “read-only reference”</li>
        <li class="fragment">Prevents accidental modification of inputs</li>
        <li class="fragment">Makes the function usable with <code>const</code> objects</li>
        <li class="fragment">Compiler enforces the rule — safer code!</li>
      </ul>
    </section>
    <section>
    <h2> function overloads </h2>
    </section>
<section>
  <h2> Build Error</h2>
  <div>
    <ul>
      <li>
        Declaring two functions with the same name and the same parameter types with different return types
      </li>
    </ul>
    <pre><code class="language-cpp" data-trim data-line-numbers>
        #include &lt;iostream&gt;
        using namespace std;

        int f(){
          return 0;
        };
        double f(){
          return 0.0;
        }

        int main() {
          return 0;
        }
        </code></pre>
        </div>
</section>
<section>
  <h2> Example </h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;

      int f(bool t, char c){
        return 0;
      }
      double f(bool f, char s){
        return 0.0;
      }
      int main() {
        return 0;
      }
      </code></pre>
</section>
<section>
  <h2>Function Overloading</h2>
  <ul>
    <li> It is legal to define multiple functions with the same name if they have different parameter types or numbers of parameters.</li>
  </ul>
    <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;

      int f(int x){
        return x;
      }
      double f(double y){
        return y;
      }
      int main() {
        cout &lt;&lt; f(5) &lt;&lt; endl;    // Calls f(int)
        cout &lt;&lt; f(3.14) &lt;&lt; endl; // Calls f(double)
        return 0;
      }
      </code></pre>
</section>
<section>
  <h2>Example</h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;

      void print(vector&lt;int&gt;& v){
        for(size_t i = 0; i &lt; v.size(); ++i){
          cout &lt;&lt; v[i] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
      }
      void print(vector&lt;double&gt;& v){
        for(size_t i = 0; i &lt; v.size(); ++i){
          cout &lt;&lt; v[i] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
      }
      void print(vector&lt;char&gt;& v){
        for(size_t i = 0; i &lt; v.size(); ++i){
          cout &lt;&lt; v[i] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
      }
      int main() {
        vector&lt;int&gt; vi{1, 2, 3};
        vector&lt;double&gt; vd{3.14, 2.71};
        vector&lt;char&gt; vc{'a', 'b', 'c'};
        print(vi);
        print(vd);
        print(vc);
        return 0;
      }
      </code></pre>
</section>
<section>
  <h2> Example</h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;

      void f(int a, int b, double c){
        cout &lt;&lt; "Three ints: " &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; ", " &lt;&lt; c &lt;&lt; endl;
      }
      void f(int a, double b, double c){
        cout &lt;&lt; "One int, two doubles: " &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; ", " &lt;&lt; c &lt;&lt; endl;
      }
      int main() {
        f(1, 2, 3.3);       // Calls f(int, int, double)
        f(1, 2.2, 3.3);   // Calls f(int, double, double)
        f(1, 2, 3);         // Calls f(int, int, double) with implicit conversion
        f(1.1, 2.2, 3.3);   // Calls f(int, double, double) with implicit conversion
        return 0;
      }
      </code></pre>
</section>
<section>
  <h2> Example </h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;

      void f(int a, double b){
        cout &lt;&lt; "int, double: " &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; endl;
      }
      void f(double a, int b){
        cout &lt;&lt; "double, int: " &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; endl;
      }
      int main() {
        f(1, 2.2);   // Calls f(int, double)
        f(1.1, 2);   // Calls f(double, int)
        return 0;
      }
      </code></pre>
</section>
<section>
  <h2> Build Error </h2>
  <ul>
    <li>
     When there is not a “best” viable candidate function, a function call gives a build error.
    </li>
    <li>
      To regard one function overload as a “better” match than another function overload, it must be equal or “better” in every argument/parameter position and strictly “better” in at least one argument/parameter position.
      </li>
      <li>
      If we are to regard one function overload as a “better” match than another function overload, it cannot be “worse” in any argument/parameter position. 

      </li>
  </ul>
</section>
<section>
  <h2> Example </h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;

      void f(int a, int b, int c){
        cout &lt;&lt; "Three ints: " &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; ", " &lt;&lt; c &lt;&lt; endl;
      }
      void f(double a, double b, double c){
        cout &lt;&lt; "Three doubles: " &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; ", " &lt;&lt; c &lt;&lt; endl;
      }
      int main() {
        f(1, 2.2, 3);   // Error: ambiguous call
        return 0;
      }
      </code></pre>
</section>
<section>
  <h2> Example</h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;

      void f( vector&lt;int&gt;& v){
        cout &lt;&lt; "Vector of ints" &lt;&lt; endl;
      }
      void f(const vector&lt;int&gt;& v){
        cout &lt;&lt; "Const vector of ints" &lt;&lt; endl;
      }
      int main() {
        vector&lt;int&gt; vi{1, 2, 3};
        const vector&lt;int&gt; cvi{4, 5, 6};
        f(vi);
        f(cvi);
        return 0;
      }
      </code></pre>
</section>

<section>
  <h2> Example</h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;
      void f() { cout &lt;&lt; '1' &lt;&lt; endl ; }
      void f( char c) { cout &lt;&lt; '2' &lt;&lt; c &lt;&lt; endl ; }
      void f( bool b, char c) { cout &lt;&lt; '3' &lt;&lt; b &lt;&lt; endl ; }
      int main () {
        f('c', false );
        return 0;
      }
      </code></pre>
</section>
  <section>
  <h2> Example</h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;
      void f( int i) { cout &lt;&lt; '1' &lt;&lt; i &lt;&lt; endl ; }
      void f( char c) { cout &lt;&lt; '2' &lt;&lt; c &lt;&lt; endl ; }
      int main () {
        f(0.0);
        return 0;
      }
      </code></pre>
  </section>
  <section>
  <h2> Example</h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;
      void f( int i) { cout &lt;&lt; '1' &lt;&lt; i &lt;&lt; endl ; }
      void f( double c) { cout &lt;&lt; '2' &lt;&lt; c &lt;&lt; endl ; }
      int main () {
        f('X');
        return 0;
      }
      </code></pre>
  </section>
  
    </div>
    </div>

  <script src="../reveal.js/dist/reveal.js"></script>
  <script src="../reveal.js/plugin/highlight/highlight.js"></script>
  <script>
    Reveal.initialize({
      center: true,
      hash: true,
      plugins: [ RevealHighlight ]
    });
  </script>
</body>
</html>