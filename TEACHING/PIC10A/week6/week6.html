<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Section 11</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="../reveal.js/dist/reveal.css">
  <link rel="stylesheet" href="../reveal.js/dist/theme/white.css" id="theme">
  <link rel="stylesheet" href="../reveal.js/plugin/highlight/monokai.css">
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <h2>Section 11: vector</h2>
        <p>In this section, we will cover the concept of vectors in programming.</p>
      </section>
<section>
<h3>Note: <code>std::vector&lt;T&gt;</code> is a class template; each <code>T</code> yields a distinct type.
</h3>
<pre><code data-trim data-line-numbers class="language-cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

int main() {
  vector&lt;int&gt; vector_of_ints;
  vector&lt;double&gt; vector_of_doubles;
  vector&lt;string&gt; vector_of_strings;
  vector&lt;vector&lt;int&gt;&gt; vector_of_vector_of_ints;
}
</code></pre>
</section>

<section>
<h3>push_back, pop_back(), operator[], and at()</h3>
<pre><code data-trim data-line-numbers class="language-cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;
int main() {
  vector&lt;int&gt; v;
  v.push_back(9);
  v.push_back(8);
  v.push_back(7);
  cout &lt;&lt; "v contains " &lt;&lt; v.size() &lt;&lt; " elements\n";
  cout &lt;&lt; "v[0]=" &lt;&lt; v[0] &lt;&lt; " v[1]=" &lt;&lt; v[1] &lt;&lt; " v[2]=" &lt;&lt; v[2] &lt;&lt; "\n\n";
  return 0;
}
</code></pre>
</section>

<section>
  <h3> Runtime Error and Undefined Behavior</h3>
  <pre><code data-trim data-line-numbers class="language-cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;
int main() {
  vector&lt;int&gt; v;
  v.push_back(1);
  v.push_back(2);
  v.push_back(3);
  cout &lt;&lt; v[10] &lt;&lt; "\n";  // Undefined behavior
  cout &lt;&lt; v.at(10) &lt;&lt; "\n"; // Runtime error: throws out_of_range exception

  v.pop_back();
  v.pop_back();
  v.pop_back();
  cout &lt;&lt; "After pop_back() again, v contains " &lt;&lt; v.size() &lt;&lt; " elements\n";
  v.pop_back(); //undefined behavior
  cout &lt;&lt; "After pop_back() again, v contains " &lt;&lt; v.size() &lt;&lt; " elements\n";
  return 0;
}
</code></pre>
</section>

<section>
<h3>Printing Elements</h3>
<pre><code data-trim data-line-numbers  class="language-cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;
int main() {
  vector&lt;string&gt; v;
  v.push_back("apple");
  v.push_back("banana");
  v.push_back("cherry");

  cout &lt;&lt; "They are ";
  for (size_t i = 0, N = v.size(); i &lt; N; ++i) {
    cout &lt;&lt; v[i] &lt;&lt; ' ';
  }
  cout &lt;&lt; "\n\n";
return 0;
}
</code></pre>
</section>

<section>
  <h2> size and capacity</h2>
  <pre><code data-trim data-line-numbers class="language-cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int main() {
  vector&lt;int&gt; v;
  cout &lt;&lt; "Initially: size=" &lt;&lt; v.size() &lt;&lt; " capacity=" &lt;&lt; v.capacity() &lt;&lt; "\n";
  for (int i = 1; i &lt;= 10; ++i) {
    v.push_back(i);
    cout &lt;&lt; "After pushing " &lt;&lt; i &lt;&lt; ": size=" &lt;&lt; v.size() &lt;&lt; " capacity=" &lt;&lt; v.capacity() &lt;&lt; "\n";
  }
  return 0;
}
</code></pre>
</section>

<section>
  <h2> size and capacity</h2>
  <div>
    <ul>
      <li><strong>Size</strong>: The number of elements currently stored in the vector. You can get the size using the <code>size()</code> member function.</li>
      <li><strong>Capacity</strong>: The amount of memory allocated for the vector, which may be larger than the current size. You can get the capacity using the <code>capacity()</code> member function.</li>
    </ul>
  </div>
</section>
<section>
  <h3> Why size and capacity?</h3>
  <div>
    <ul>
      <li>When you add elements to a vector using <code>push_back()</code>, if the current size exceeds the capacity, the vector will automatically allocate more memory to accommodate the new elements. This process is called reallocation.</li>
      <li>Reallocation can be costly in terms of performance because it involves allocating new memory, copying existing elements to the new memory location, and then deallocating the old memory.</li>
    </ul>
</section>
<section>
  <h3> Example</h3>
  <pre><code data-trim data-line-numbers class="language-cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;time.h&gt;
using namespace std;
void myvector_foo(int N){
    vector&lt;int&gt; v;
    for (int i = 0; i &lt; N; ++i) {
        v.push_back(i%100);
    }
}
void myvector_bar(int N){
    vector&lt;int&gt; v(N); //pre-allocate memory
    for (int i = 0; i &lt; N; ++i) {
        v[i] = i%100;
    }
}
int main() {  
    int N;
    cin &gt;&gt; N;
    clock_t start, end;

    start = clock();
    myvector_foo(N);
    end = clock();
    cout &lt;&lt; "Time taken by myvector_foo: " &lt;&lt; static_cast&lt; double &gt;(end - start) / CLOCKS_PER_SEC &lt;&lt; " seconds\n";

    start = clock();
    myvector_bar(N);
    end = clock();
    cout &lt;&lt; "Time taken by myvector_bar: " &lt;&lt; static_cast&lt; double &gt;(end - start) / CLOCKS_PER_SEC &lt;&lt; " seconds\n";
    return 0;
}
</code></pre>
</section>
<section>
  <h3> resize a vector</h3>
  <pre><code data-trim data-line-numbers class="language-cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
void printVector(vector&lt;int&gt; vec) {
    for (size_t i = 0; i &lt; vec.size(); ++i) {
        cout &lt;&lt; vec[i] &lt;&lt; ' ';
    }
    cout &lt;&lt; "\n";
}

int main() {
    vector&lt;int&gt; v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    printVector(v);
    cout &lt;&lt; "Initially: size=" &lt;&lt; v.size() &lt;&lt; " capacity=" &lt;&lt; v.capacity() &lt;&lt; "\n";
    v.resize(5);
    printVector(v);
    cout &lt;&lt; "After resize(5): size=" &lt;&lt; v.size() &lt;&lt; " capacity=" &lt;&lt; v.capacity() &lt;&lt; "\n";
    v.resize(10,1);
    printVector(v);
    cout &lt;&lt; "After resize(10): size=" &lt;&lt; v.size() &lt;&lt; " capacity=" &lt;&lt; v.capacity() &lt;&lt; "\n";
    v.resize(3);
    printVector(v);
    cout &lt;&lt; "After resize(3): size=" &lt;&lt; v.size() &lt;&lt; " capacity=" &lt;&lt; v.capacity() &lt;&lt; "\n";
    return 0;
}
</code></pre>
</section>
<section>
  <h3> function that add two vectors </h3>
  <pre><code data-trim data-line-numbers class="language-cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;time.h&gt;
using namespace std;

vector&lt;int&gt; addVectors_foo(vector&lt;int&gt; v1, vector&lt;int&gt; v2) {
    size_t size = min(v1.size(), v2.size());
    vector&lt;int&gt; result(size);
    for (size_t i = 0; i &lt; size; ++i) {
        result[i] = v1[i] + v2[i];
    }
    return result;
}
void addVectors_bar(const vector&lt;int&gt; &amp;v1, const vector&lt;int&gt; &amp;v2, vector&lt;int&gt; &amp;result) {
    size_t size = min(v1.size(), v2.size());
    for (size_t i = 0; i &lt; size; ++i) {
        result[i] = v1[i] + v2[i];
    }
}

int main() {
    int N;
    cin &gt;&gt; N;
    vector&lt;int&gt; vec1(N, 1);
    vector&lt;int&gt; vec2(N, 2);
    vector&lt;int&gt; sum(N);
    clock_t start, end;

    start = clock();
    sum = addVectors_foo(vec1, vec2);
    end = clock();
    cout &lt;&lt; "Time taken by addVectors_foo: " &lt;&lt; static_cast&lt; double &gt;(end - start) / CLOCKS_PER_SEC &lt;&lt; " seconds\n";

    start = clock();
    addVectors_bar(vec1, vec2, sum);
    end = clock();
    cout &lt;&lt; "Time taken by addVectors_bar: " &lt;&lt; static_cast&lt; double &gt;(end - start) / CLOCKS_PER_SEC &lt;&lt; " seconds\n";
    return 0;
}
</code></pre>
</section>
    <section>
      <h2> How to choose parameter types</h2>
      </section>
      <section>
        <h2> Different parameter types</h2>
        <ul>
          <li>
            <strong>Passing by value</strong>
            <ul>
              <li>Makes a copy of the argument</li>
              <li>Changes inside the function do <em>not</em> affect the caller</li>
              <li>Simple and safe, good for small types (e.g., <code>int</code>, <code>double</code>)</li>
            </ul>
          </li>
        </ul>
      </section>
      <section>
          <li>
            <strong>Passing by reference</strong>
            <ul>
              <li>No copy is made (more efficient for large objects)</li>
              <li>Function can modify the caller’s variable</li>
              <li>Use when you <em>want</em> to change the argument</li>
            </ul>
          </li>
        </ul>
      </section>
      <section>
          <li>
            <strong>Passing by reference to const</strong>
            <ul>
              <li>No copy is made (efficient for large objects)</li>
              <li>Function cannot modify the argument</li>
              <li>Use when you only need to read from a large object</li>
            </ul>
          </li>
        </ul>
      </section>
      <section>
      <h2>Choosing Parameter Types in C++</h2>
      <p>Given a type <code>T</code> (without <code>const</code> or <code>&</code>):</p>
      <ul>
        <li class="fragment"><strong>Pass by value</strong>: <code>T</code> (makes a copy)</li>
        <li class="fragment"><strong>Pass by reference</strong>: <code>T&amp;</code> (can modify original)</li>
        <li class="fragment"><strong>Pass by reference to const</strong>: <code>const T&amp;</code> (no copy, cannot modify)</li>
      </ul>
    </section>

    <section>
      <h2>How to Choose</h2>
      <ol>
        <li class="fragment">
          <strong>Do we want to mutate the argument?</strong>
          <ul>
            <li>If <strong>yes</strong> → use <code>T&amp;</code></li>
            <li>If <strong>no</strong> → choose between <code>T</code> and <code>const T&amp;</code></li>
          </ul>
        </li>
        <li class="fragment">
          <strong>Do we want to avoid copying?</strong>
          <ul>
            <li>If <strong>yes</strong> → use <code>T&amp;</code> or <code>const T&amp;</code></li>
            <li>If <strong>no</strong>:
              <ul>
                <li>If copying doesn’t matter → <code>T</code> is simplest</li>
                <li>If we really want a copy → use <code>T</code> (or copy inside)</li>
              </ul>
            </li>
          </ul>
        </li>
      </ol>
    </section>
    <section>
        <h2>Example 12.1.3 — Const Correctness</h2>
        <pre><code class="language-cpp" data-trim data-line-numbers>
        #include &lt;iostream&gt;
        #include &lt;vector&gt;
        using namespace std;

        int sum(const vector&lt;int&gt;& v) {
            int sum = 0;
            for (size_t i = 0, N = v.size(); i &lt; N; ++i)
                sum += v[i];
            return sum;
        }

        void print_sum(const vector&lt;int&gt;& v) {
            cout &lt;&lt; sum(v) &lt;&lt; endl;
        }

        int main() {
            vector&lt;int&gt; w{1, 2, 3};
            print_sum(w);
        }
          </code></pre>
    </section>
    <section>
      <h2>What Does “Const Correct” Mean?</h2>
      <ul>
        <li class="fragment"><code>const vector&lt;int&gt;&amp;</code> means “read-only reference”</li>
        <li class="fragment">Prevents accidental modification of inputs</li>
        <li class="fragment">Makes the function usable with <code>const</code> objects</li>
        <li class="fragment">Compiler enforces the rule — safer code!</li>
      </ul>
    </section>
    <section>
    <h2> function overloads </h2>
    </section>
<section>
  <h2> Build Error</h2>
  <div>
    <ul>
      <li>
        Declaring two functions with the same name and the same parameter types with different return types
      </li>
    </ul>
    <pre><code class="language-cpp" data-trim data-line-numbers>
        #include &lt;iostream&gt;
        using namespace std;

        int f(){
          return 0;
        };
        double f(){
          return 0.0;
        }

        int main() {
          return 0;
        }
        </code></pre>
        </div>
</section>
<section>
  <h2> Example </h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;

      int f(bool t, char c){
        return 0;
      }
      double f(bool f, char s){
        return 0.0;
      }
      int main() {
        return 0;
      }
      </code></pre>
</section>
<section>
  <h2>Function Overloading</h2>
  <ul>
    <li> It is legal to define multiple functions with the same name if they have different parameter types or numbers of parameters.</li>
  </ul>
    <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;

      int f(int x){
        return x;
      }
      double f(double y){
        return y;
      }
      int main() {
        cout &lt;&lt; f(5) &lt;&lt; endl;    // Calls f(int)
        cout &lt;&lt; f(3.14) &lt;&lt; endl; // Calls f(double)
        return 0;
      }
      </code></pre>
</section>
<section>
  <h2>Example</h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;

      void print(vector&lt;int&gt;& v){
        for(size_t i = 0; i &lt; v.size(); ++i){
          cout &lt;&lt; v[i] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
      }
      void print(vector&lt;double&gt;& v){
        for(size_t i = 0; i &lt; v.size(); ++i){
          cout &lt;&lt; v[i] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
      }
      void print(vector&lt;char&gt;& v){
        for(size_t i = 0; i &lt; v.size(); ++i){
          cout &lt;&lt; v[i] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
      }
      int main() {
        vector&lt;int&gt; vi{1, 2, 3};
        vector&lt;double&gt; vd{3.14, 2.71};
        vector&lt;char&gt; vc{'a', 'b', 'c'};
        print(vi);
        print(vd);
        print(vc);
        return 0;
      }
      </code></pre>
</section>
<section>
  <h2> Example</h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;

      void f(int a, int b, double c){
        cout &lt;&lt; "Three ints: " &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; ", " &lt;&lt; c &lt;&lt; endl;
      }
      void f(int a, double b, double c){
        cout &lt;&lt; "One int, two doubles: " &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; ", " &lt;&lt; c &lt;&lt; endl;
      }
      int main() {
        f(1, 2, 3.3);       // Calls f(int, int, double)
        f(1, 2.2, 3.3);   // Calls f(int, double, double)
        f(1, 2, 3);         // Calls f(int, int, double) with implicit conversion
        f(1.1, 2.2, 3.3);   // Calls f(int, double, double) with implicit conversion
        return 0;
      }
      </code></pre>
</section>
<section>
  <h2> Example </h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;

      void f(int a, double b){
        cout &lt;&lt; "int, double: " &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; endl;
      }
      void f(double a, int b){
        cout &lt;&lt; "double, int: " &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; endl;
      }
      int main() {
        f(1, 2.2);   // Calls f(int, double)
        f(1.1, 2);   // Calls f(double, int)
        return 0;
      }
      </code></pre>
</section>
<section>
  <h2> Build Error </h2>
  <ul>
    <li>
     When there is not a “best” viable candidate function, a function call gives a build error.
    </li>
    <li>
      To regard one function overload as a “better” match than another function overload, it must be equal or “better” in every argument/parameter position and strictly “better” in at least one argument/parameter position.
      </li>
      <li>
      If we are to regard one function overload as a “better” match than another function overload, it cannot be “worse” in any argument/parameter position. 

      </li>
  </ul>
</section>
<section>
  <h2> Example </h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;

      void f(int a, int b, int c){
        cout &lt;&lt; "Three ints: " &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; ", " &lt;&lt; c &lt;&lt; endl;
      }
      void f(double a, double b, double c){
        cout &lt;&lt; "Three doubles: " &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; ", " &lt;&lt; c &lt;&lt; endl;
      }
      int main() {
        f(1, 2.2, 3);   // Error: ambiguous call
        return 0;
      }
      </code></pre>
</section>
<section>
  <h2> Example</h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;

      void f( vector&lt;int&gt;& v){
        cout &lt;&lt; "Vector of ints" &lt;&lt; endl;
      }
      void f(const vector&lt;int&gt;& v){
        cout &lt;&lt; "Const vector of ints" &lt;&lt; endl;
      }
      int main() {
        vector&lt;int&gt; vi{1, 2, 3};
        const vector&lt;int&gt; cvi{4, 5, 6};
        f(vi);
        f(cvi);
        return 0;
      }
      </code></pre>
</section>

<section>
  <h2> Example</h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;
      void f() { cout &lt;&lt; '1' &lt;&lt; endl ; }
      void f( char c) { cout &lt;&lt; '2' &lt;&lt; c &lt;&lt; endl ; }
      void f( bool b, char c) { cout &lt;&lt; '3' &lt;&lt; b &lt;&lt; endl ; }
      int main () {
        f('c', false );
        return 0;
      }
      </code></pre>
</section>
  <section>
  <h2> Example</h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;
      void f( int i) { cout &lt;&lt; '1' &lt;&lt; i &lt;&lt; endl ; }
      void f( char c) { cout &lt;&lt; '2' &lt;&lt; c &lt;&lt; endl ; }
      int main () {
        f(0.0);
        return 0;
      }
      </code></pre>
  </section>
  <section>
  <h2> Example</h2>
  <pre><code class="language-cpp" data-trim data-line-numbers>
      #include &lt;iostream&gt;
      using namespace std;
      void f( int i) { cout &lt;&lt; '1' &lt;&lt; i &lt;&lt; endl ; }
      void f( double c) { cout &lt;&lt; '2' &lt;&lt; c &lt;&lt; endl ; }
      int main () {
        f('X');
        return 0;
      }
      </code></pre>
  </section>
    </div>
  </div>  

  <script src="../reveal.js/dist/reveal.js"></script>
  <script src="../reveal.js/plugin/highlight/highlight.js"></script>
  <script>
    Reveal.initialize({
      center: true,
      hash: true,
      plugins: [ RevealHighlight ]
    });
  </script>
</body>
</html>